{"ast":null,"code":"import { cloneNode } from './clone-node';\nimport { embedImages } from './embed-images';\nimport { applyStyle } from './apply-style';\nimport { embedWebFonts, getWebFontCSS } from './embed-webfonts';\nimport { getImageSize, getPixelRatio, createImage, canvasToBlob, nodeToDataURL, checkCanvasDimensions } from './util';\nexport async function toSvg(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    width,\n    height\n  } = getImageSize(node, options);\n  const clonedNode = await cloneNode(node, options, true);\n  await embedWebFonts(clonedNode, options);\n  await embedImages(clonedNode, options);\n  applyStyle(clonedNode, options);\n  const datauri = await nodeToDataURL(clonedNode, width, height);\n  return datauri;\n}\nexport async function toCanvas(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    width,\n    height\n  } = getImageSize(node, options);\n  const svg = await toSvg(node, options);\n  const img = await createImage(svg);\n  const canvas = document.createElement('canvas');\n  const context = canvas.getContext('2d');\n  const ratio = options.pixelRatio || getPixelRatio();\n  const canvasWidth = options.canvasWidth || width;\n  const canvasHeight = options.canvasHeight || height;\n  canvas.width = canvasWidth * ratio;\n  canvas.height = canvasHeight * ratio;\n  if (!options.skipAutoScale) {\n    checkCanvasDimensions(canvas);\n  }\n  canvas.style.width = \"\".concat(canvasWidth);\n  canvas.style.height = \"\".concat(canvasHeight);\n  if (options.backgroundColor) {\n    context.fillStyle = options.backgroundColor;\n    context.fillRect(0, 0, canvas.width, canvas.height);\n  }\n  context.drawImage(img, 0, 0, canvas.width, canvas.height);\n  return canvas;\n}\nexport async function toPixelData(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    width,\n    height\n  } = getImageSize(node, options);\n  const canvas = await toCanvas(node, options);\n  const ctx = canvas.getContext('2d');\n  return ctx.getImageData(0, 0, width, height).data;\n}\nexport async function toPng(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const canvas = await toCanvas(node, options);\n  return canvas.toDataURL();\n}\nexport async function toJpeg(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const canvas = await toCanvas(node, options);\n  return canvas.toDataURL('image/jpeg', options.quality || 1);\n}\nexport async function toBlob(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const canvas = await toCanvas(node, options);\n  const blob = await canvasToBlob(canvas);\n  return blob;\n}\nexport async function getFontEmbedCSS(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return getWebFontCSS(node, options);\n}","map":{"version":3,"names":["cloneNode","embedImages","applyStyle","embedWebFonts","getWebFontCSS","getImageSize","getPixelRatio","createImage","canvasToBlob","nodeToDataURL","checkCanvasDimensions","toSvg","node","options","arguments","length","undefined","width","height","clonedNode","datauri","toCanvas","svg","img","canvas","document","createElement","context","getContext","ratio","pixelRatio","canvasWidth","canvasHeight","skipAutoScale","style","concat","backgroundColor","fillStyle","fillRect","drawImage","toPixelData","ctx","getImageData","data","toPng","toDataURL","toJpeg","quality","toBlob","blob","getFontEmbedCSS"],"sources":["/home/saim/Desktop/Projects/BoloGrocery/node_modules/html-to-image/src/index.ts"],"sourcesContent":["import { Options } from './types'\nimport { cloneNode } from './clone-node'\nimport { embedImages } from './embed-images'\nimport { applyStyle } from './apply-style'\nimport { embedWebFonts, getWebFontCSS } from './embed-webfonts'\nimport {\n  getImageSize,\n  getPixelRatio,\n  createImage,\n  canvasToBlob,\n  nodeToDataURL,\n  checkCanvasDimensions,\n} from './util'\n\nexport async function toSvg<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<string> {\n  const { width, height } = getImageSize(node, options)\n  const clonedNode = (await cloneNode(node, options, true)) as HTMLElement\n  await embedWebFonts(clonedNode, options)\n  await embedImages(clonedNode, options)\n  applyStyle(clonedNode, options)\n  const datauri = await nodeToDataURL(clonedNode, width, height)\n  return datauri\n}\n\nexport async function toCanvas<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<HTMLCanvasElement> {\n  const { width, height } = getImageSize(node, options)\n  const svg = await toSvg(node, options)\n  const img = await createImage(svg)\n\n  const canvas = document.createElement('canvas')\n  const context = canvas.getContext('2d')!\n  const ratio = options.pixelRatio || getPixelRatio()\n  const canvasWidth = options.canvasWidth || width\n  const canvasHeight = options.canvasHeight || height\n\n  canvas.width = canvasWidth * ratio\n  canvas.height = canvasHeight * ratio\n\n  if (!options.skipAutoScale) {\n    checkCanvasDimensions(canvas)\n  }\n  canvas.style.width = `${canvasWidth}`\n  canvas.style.height = `${canvasHeight}`\n\n  if (options.backgroundColor) {\n    context.fillStyle = options.backgroundColor\n    context.fillRect(0, 0, canvas.width, canvas.height)\n  }\n\n  context.drawImage(img, 0, 0, canvas.width, canvas.height)\n\n  return canvas\n}\n\nexport async function toPixelData<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<Uint8ClampedArray> {\n  const { width, height } = getImageSize(node, options)\n  const canvas = await toCanvas(node, options)\n  const ctx = canvas.getContext('2d')!\n  return ctx.getImageData(0, 0, width, height).data\n}\n\nexport async function toPng<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<string> {\n  const canvas = await toCanvas(node, options)\n  return canvas.toDataURL()\n}\n\nexport async function toJpeg<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<string> {\n  const canvas = await toCanvas(node, options)\n  return canvas.toDataURL('image/jpeg', options.quality || 1)\n}\n\nexport async function toBlob<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<Blob | null> {\n  const canvas = await toCanvas(node, options)\n  const blob = await canvasToBlob(canvas)\n  return blob\n}\n\nexport async function getFontEmbedCSS<T extends HTMLElement>(\n  node: T,\n  options: Options = {},\n): Promise<string> {\n  return getWebFontCSS(node, options)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}